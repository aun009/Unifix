#!/usr/bin/env bash
set -euo pipefail

# Network_Info.sh
# Collect a comprehensive, read-only snapshot of the host's network configuration and runtime state.
# Usage: Network_Info.sh [--test]
#  --test  : perform basic connectivity tests (ping/traceroute/curl)

TEST_CONNECTIVITY=0
for arg in "$@"; do
  case "$arg" in
    --test) TEST_CONNECTIVITY=1 ;;
    *) ;;
  esac
done

SUDO=""
if [[ $(id -u) -ne 0 ]] && command -v sudo >/dev/null 2>&1; then
  SUDO=sudo
fi

TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
OUTFILE="/tmp/network_info_${TIMESTAMP}.log"

# Run command and print a formatted header
run_cmd() {
  local title="$1"; shift
  echo
  echo "================================================================="
  echo "# $title"
  echo "================================================================="
  echo
  if [[ ${#@} -eq 0 ]]; then
    return 0
  fi
  if ! "$@"; then
    echo "[command failed: $*]" >&2 || true
  fi
}

run_priv_cmd() {
  local title="$1"; shift
  run_cmd "$title" ${SUDO:+$SUDO} -- "$@"
}

# Helper to try several commands
try_cmd() {
  for cmd in "$@"; do
    if command -v "$cmd" >/dev/null 2>&1; then
      echo "$cmd"
      return 0
    fi
  done
  return 1
}

{
  echo "Network information snapshot: ${TIMESTAMP}"
  echo "Generated by: Network_Info.sh"
  echo "Host: $(hostname -f 2>/dev/null || hostname)"
  echo "User: $(id -un) (uid: $(id -u))"
  echo "Uptime: $(uptime -p 2>/dev/null || true)"
  echo

  run_cmd "Kernel & OS" uname -a
  if command -v lsb_release >/dev/null 2>&1; then
    run_cmd "LSB Release" lsb_release -a
  fi
  if [[ -f /etc/os-release ]]; then
    run_cmd "/etc/os-release" cat /etc/os-release
  fi
  run_cmd "hostnamectl" hostnamectl || true

  run_cmd "/etc/hosts" cat /etc/hosts || true
  run_cmd "/etc/resolv.conf" cat /etc/resolv.conf || true

  # Network interfaces and addresses
  IP_CMD=$(try_cmd ip)
  if [[ -n "$IP_CMD" ]]; then
    run_cmd "ip link show (links)" ip -d link show
    run_cmd "ip addr show (addresses)" ip -d addr show
    run_cmd "ip -s link (statistics)" ip -s link
    run_cmd "ip -s addr (addr stats)" ip -s addr
    run_cmd "ip route (IPv4)" ip route show
    run_cmd "ip -6 route (IPv6)" ip -6 route show || true
    run_cmd "ip neigh (ARP/neighbor)" ip neigh show
  else
    IFCONFIG_CMD=$(try_cmd ifconfig)
    if [[ -n "$IFCONFIG_CMD" ]]; then
      run_cmd "ifconfig -a" ifconfig -a
    fi
    NETSTAT_CMD=$(try_cmd netstat)
    if [[ -n "$NETSTAT_CMD" ]]; then
      run_cmd "netstat -rn" netstat -rn
    fi
  fi

  # Routing and policy
  run_cmd "ip rule show" ip rule show || true
  run_cmd "ip route get 8.8.8.8" ip route get 8.8.8.8 || true

  # Neighbor and ARP caches
  run_cmd "arp -n" arp -n || true

  # NetworkManager / systemd-networkd
  if command -v nmcli >/dev/null 2>&1; then
    run_cmd "NetworkManager: nmcli device status" nmcli device status
    run_cmd "NetworkManager: nmcli connection show" nmcli connection show
    run_cmd "NetworkManager: nmcli -t -f IP4,IP6 device show" nmcli -t -f IP4,IP6 device show || true
  fi
  if command -v resolvectl >/dev/null 2>&1; then
    run_cmd "systemd-resolved: resolvectl status" resolvectl status || true
  elif command -v systemd-resolve >/dev/null 2>&1; then
    run_cmd "systemd-resolve --status" systemd-resolve --status || true
  fi
  if systemctl list-units --type=service --all | grep -qi networkd; then
    run_cmd "systemd-networkd status" ${SUDO:+$SUDO} systemctl status systemd-networkd --no-pager || true
  fi

  # Firewalls
  if command -v ufw >/dev/null 2>&1; then
    run_priv_cmd "UFW status" ufw status verbose || true
  fi
  if command -v nft >/dev/null 2>&1; then
    run_priv_cmd "nft list ruleset" nft list ruleset || true
  fi
  if command -v iptables >/dev/null 2>&1; then
    run_priv_cmd "iptables -S" iptables -S || true
    run_priv_cmd "iptables -L -n -v" iptables -L -n -v || true
  fi
  if command -v ip6tables >/dev/null 2>&1; then
    run_priv_cmd "ip6tables -S" ip6tables -S || true
  fi

  # Sockets and connections
  if command -v ss >/dev/null 2>&1; then
    run_cmd "ss -tunap (listening & connections)" ss -tunap || true
  elif command -v netstat >/dev/null 2>&1; then
    run_cmd "netstat -tunap" netstat -tunap || true
  fi
  if command -v lsof >/dev/null 2>&1; then
    run_priv_cmd "lsof -i -P -n | head -n 200" lsof -i -P -n || true
  fi

  # Bridges and linux-bridge info
  if command -v brctl >/dev/null 2>&1; then
    run_cmd "brctl show" brctl show || true
  fi
  if command -v bridge >/dev/null 2>&1; then
    run_cmd "bridge link" bridge link || true
    run_cmd "bridge vlan" bridge vlan || true
  fi

  # Docker networks (if Docker is present)
  if command -v docker >/dev/null 2>&1; then
    run_priv_cmd "docker info (summary)" docker info --format '{{json .}}' || true
    run_priv_cmd "docker network ls" docker network ls || true
    # Inspect each network (limit to first 10 to avoid huge output)
    docker network ls --format '{{.Name}}' 2>/dev/null | head -n 10 | while read -r net; do
      run_priv_cmd "docker network inspect ${net}" docker network inspect "$net" || true
    done
  fi

  # Wireless info
  if command -v iw >/dev/null 2>&1; then
    run_cmd "iw dev" iw dev || true
  fi
  if command -v iwconfig >/dev/null 2>&1; then
    run_cmd "iwconfig" iwconfig || true
  fi

  # ethtool per-interface
  if command -v ethtool >/dev/null 2>&1; then
    for iface in $(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' | cut -d'@' -f1); do
      # skip loopback
      if [[ "$iface" == "lo" ]]; then
        continue
      fi
      run_priv_cmd "ethtool $iface" ethtool "$iface" || true
    done
  fi

  # Kernel dmesg (recent network-related lines)
  if command -v dmesg >/dev/null 2>&1; then
    run_cmd "dmesg | tail -n 200 (recent kernel messages)" dmesg --ctime | tail -n 200 | grep -iE 'eth|net|rtnetlink|bridge|packet|tcp|udp|drop|link' || true
  fi

  # Check relevant services
  for svc in NetworkManager docker systemd-networkd firewalld ufw; do
    if systemctl list-units --type=service --all | grep -qi "^${svc}"; then
      run_priv_cmd "systemctl status ${svc}" systemctl status "${svc}" --no-pager || true
    fi
  done

  # DNS diagnostics
  if command -v dig >/dev/null 2>&1; then
    run_cmd "dig +short @127.0.0.53 google.com A" dig +short @127.0.0.53 google.com A || true
  fi

  # connectivity tests (optional)
  if [[ $TEST_CONNECTIVITY -eq 1 ]]; then
    run_cmd "Ping 8.8.8.8 (2 packets)" ping -c 2 8.8.8.8 || true
    run_cmd "Ping google.com (2 packets)" ping -c 2 google.com || true
    if command -v traceroute >/dev/null 2>&1; then
      run_cmd "traceroute 8.8.8.8 (first 15 hops)" traceroute -m 15 8.8.8.8 || true
    fi
    if command -v curl >/dev/null 2>&1; then
      run_cmd "curl -I --max-time 10 https://www.google.com" curl -I --max-time 10 https://www.google.com || true
    fi
  fi

  echo
  echo "Summary / quick checks"
  echo "----------------------"
  if command -v ip >/dev/null 2>&1; then
    echo "Default route: $(ip route show default 2>/dev/null || true)"
  fi
  echo "Nameservers: $(awk '/^nameserver/ {print $2}' /etc/resolv.conf 2>/dev/null || true)"
  echo "Local IPs:"
  if command -v ip >/dev/null 2>&1; then
    ip -4 -o addr show scope global 2>/dev/null | awk '{print $2": "$4}' || true
  fi

  echo
  echo "Log saved to: ${OUTFILE}"
  echo "To share securely, compress and redact sensitive fields before sending."

  echo
  echo "Tips:"
  echo " - Run with --test to include basic connectivity checks (pings/traceroute/curl)."
  echo " - This script performs read-only operations. Some commands may require sudo to show full details." 
  echo " - Large outputs (docker inspect, nftables) are truncated by limiting inspected networks to 10 items."

} 2>&1 | tee "$OUTFILE"

# Exit with success
exit 0
